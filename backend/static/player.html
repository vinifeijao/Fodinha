<!doctype html>
<html>
<head>
  <title>PHDNH – Browser Client</title>
  <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:;">
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; display: flex; flex-direction: column; align-items: center;background-color: #f0f0f0;}
    .view { display: none; width: 80%; max-width: 700px; margin-top: 15px; padding: 15px; border: 1px solid #ccc; border-radius: 8px; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .view.active { display: block; }
    #log { white-space: pre-wrap; font-size: 13px; border: 1px solid #eee; padding: 10px; height: 200px; overflow-y: auto; margin-top: 10px; background-color: #f9f9f9; line-height: 1.4; }
    button { margin: 5px; padding: 8px 12px; cursor: pointer; border-radius: 4px; border: 1px solid #ddd; background-color: #e7e7e7; }
    button:hover { background-color: #d7d7d7; }
    button:disabled { cursor: not-allowed; background-color: #f5f5f5; color: #aaa; }
    input[type="text"], input[type="number"] { padding: 8px; margin: 5px 0; border-radius: 4px; border: 1px solid #ddd; }
    h2, h3, h4 { text-align: center; color: #333; }
    .player-list li { list-style-type: none; padding: 3px 0; }
    .info-bar { margin-bottom: 10px; font-weight: bold; color: #555; }
    .game-info div { margin-bottom: 5px; }
    .palpite-section { margin-top: 15px; padding: 10px; border: 1px dashed #ddd; border-radius: 4px; }
    .my-turn { border: 2px solid green; padding: 8px; }
    .error-msg { color: red; font-weight: bold; }
    
    /* New card display styles */
    .card-display { 
      background-color: #f8f8f8; 
      border: 1px solid #ddd; 
      border-radius: 5px; 
      padding: 10px; 
      margin: 10px 0;
    }
    .card-item {
      display: inline-block;
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 5px 10px;
      margin: 3px;
      background-color: white;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .card-red { color: red; }
    .card-black { color: black; }
    .hidden-card { 
      background-color: #eaeaea; 
      color: #999; 
      font-style: italic;
    }
    .other-players-section {
      margin-top: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 10px;
      background-color: #f5f5f5;
    }
    .other-players-section h4 {
      margin-top: 0;
    }
    
    /* New styles for card selection */
    .card-selection-btn {
      cursor: pointer;
      padding: 8px 12px;
      margin: 5px;
      border: 1px solid #ccc;
      border-radius: 5px;
      background-color: white;
      transition: all 0.2s;
    }
    .card-selection-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 3px 5px rgba(0,0,0,0.2);
    }
    .card-selection-btn.card-red { color: red; }
    .card-selection-btn.card-black { color: black; }
    
    /* Lives tracker styles */
    .lives-tracker {
      margin-bottom: 15px;
      background-color: #f0f0f0;
    }
    .lives-count {
      display: inline-block;
      width: 25px;
      height: 25px;
      line-height: 25px;
      text-align: center;
      border-radius: 50%;
      background-color: #4CAF50;
      color: white;
      margin-left: 5px;
    }
    .low-lives {
      background-color: #FFC107;
    }
    .critical-lives {
      background-color: #F44336;
    }
    
    /* Round results section */
    .round-results-section {
      margin-top: 15px;
      padding: 10px;
      border: 1px solid #4CAF50;
      border-radius: 5px;
      background-color: #f0fff0;
    }
    .lives-lost-item {
      font-weight: bold;
    }
    .lives-lost-zero {
      color: green;
    }
    .lives-lost-nonzero {
      color: red;
    }
    
    /* Cards in play styling */
    .player-card-played {
      margin: 8px 0;
      padding: 5px;
      border-radius: 5px;
    }
    .current-player-card {
      background-color: #e6f7ff;
      border-left: 3px solid #1890ff;
    }
    .card-player-name {
      font-weight: bold;
      margin-right: 8px;
    }

    /* New styles for the persistent palpite tracker */
    .palpite-tracker {
      background-color: #f0f8ff;
      border: 1px solid #add8e6;
      border-radius: 5px;
      padding: 10px;
      margin: 10px 0;
    }
    .palpite-tracker-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
    }
    .palpite-tracker-item .player-name {
      font-weight: bold;
    }
    .palpite-tracker-item .palpite-value {
      font-weight: bold;
      background-color: #e6f7ff;
      border-radius: 3px;
      padding: 2px 8px;
    }
    .palpite-tracker-item .tricks-won {
      color: #4CAF50;
      font-weight: bold;
    }
    
    /* Strongest card highlight */
    .strongest-card {
      border: 2px solid #4CAF50 !important;
      background-color: #e8f5e9 !important;
      box-shadow: 0 0 5px rgba(76, 175, 80, 0.5) !important;
    }
    
    /* Trick winner styles */
    .trick-winner-display {
      margin-top: 10px;
      font-weight: bold;
      color: #4CAF50;
      background-color: #e8f5e9;
      padding: 5px;
      border-radius: 3px;
      text-align: center;
    }
    
    /* Progress tracker for tricks/palpites */
    .trick-progress {
      display: flex;
      align-items: center;
      margin-top: 10px;
    }
    .trick-progress-label {
      margin-right: 10px;
      font-weight: bold;
    }
    .trick-progress-bar {
      flex: 1;
      height: 20px;
      background-color: #e0e0e0;
      border-radius: 10px;
      overflow: hidden;
    }
    .trick-progress-fill {
      height: 100%;
      background-color: #4CAF50;
      transition: width 0.3s ease;
    }
    
    /* Card history section */
    .card-history-section {
      background-color: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 10px;
      margin: 15px 0;
    }
    .card-history-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }
    .card-history-table th,
    .card-history-table td {
      padding: 6px;
      text-align: center;
      border-bottom: 1px solid #ddd;
    }
    .card-history-table th {
      background-color: #f0f0f0;
      font-weight: bold;
    }
    .card-history-table .trick-header {
      background-color: #e0e0e0;
      font-weight: bold;
    }
    .card-history-table .trick-winner {
      background-color: #e8f5e9;
    }
    .card-history-mini-card {
      display: inline-block;
      padding: 2px 5px;
      margin: 2px;
      border-radius: 3px;
      border: 1px solid #ccc;
      font-weight: bold;
      background-color: white;
    }
    .high-value-card {
      background-color: #fff9c4;
      font-weight: bold;
      border-color: #ffd54f;
    }
    .manilha-card {
      background-color: #ffcdd2;
      font-weight: bold;
      border-color: #e57373;
    }
    
    /* New 2-column layout */
    .game-view-container {
      width: 100%;
      display: flex;
      flex-wrap: wrap;
    }
    
    .left-column {
      flex: 1;
      min-width: 300px;
      padding-right: 10px;
    }
    
    .right-column {
      flex: 1;
      min-width: 300px;
      padding-left: 10px;
    }
    
    #gameView {
      width: 95%;
      max-width: 1200px;
    }
    
    #log {
      width: 100%;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h2>PHDNH Online</h2>

  <!-- Connection Status -->
  <div id="connectionStatus" class="info-bar">Status: Disconnected</div>
  <div id="playerContext" class="info-bar" style="display:none;">Player: <span id="myPlayerId"></span> | SID: <span id="mySid"></span> | Room: <span id="myRoomId"></span></div>

  <!-- View 1: Login / Join Selection -->
  <div id="loginView" class="view active">
    <h3>Welcome!</h3>
    <label>Your Player ID: <input id="playerIdInput" placeholder="e.g., Player1" value=""></label>
    <hr>
    <button id="hostGameBtn">Host New Game</button>
    <hr>
    <label>Enter Lobby Code: <input id="lobbyCodeInput" placeholder="e.g., ABC123" value=""></label>
    <button id="joinGameBtn">Join Game by Code</button>
  </div>

  <!-- View 2: Lobby Waiting Room -->
  <div id="lobbyView" class="view">
    <h3>Lobby <span id="lobbyIdDisplay"></span></h3>
    <h4>Players in Lobby:</h4>
    <ul id="playerList" class="player-list"></ul>
    <button id="startGameBtn" style="display:none;">Start Game</button>
  </div>

  <!-- View 3: Game In Progress -->
  <div id="gameView" class="view">
    <h3 style="margin-bottom: 5px;">Game Room: <span id="gameLobbyIdDisplay"></span></h3>
    
    <div class="game-view-container">
      <!-- Left Column -->
      <div class="left-column">
        <!-- Lives Tracker -->
        <div class="lives-tracker card-display">
          <h4>Player Lives</h4>
          <ul id="livesTrackerList" class="player-list"></ul>
        </div>
        
        <div class="game-info">
            <div><strong>Round Phase:</strong> <span id="roundPhaseDisplay"></span></div>
            <div><strong>Dealer (Round):</strong> <span id="dealerRodadaAtualDisplay"></span></div>
            <div><strong>Cards in Round:</strong> <span id="nCartasRodadaAtualDisplay"></span></div>
            <div><strong>Manilha:</strong> <span id="manilhaRodadaAtualDisplay"></span> (<span id="cartaMeioRodadaAtualDisplay"></span>)</div>
            <div><strong>Your Hand:</strong> <span id="myHandDisplay"></span></div>
            
            <div id="otherPlayersCards" class="other-players-section" style="display:none;">
                <h4>Other Players' Cards (1-Card Round)</h4>
                <p><em>Note: In 1-card rounds, you can see others' cards but not your own (per game rules).</em></p>
                <div class="card-display">
                    <ul id="otherPlayersCardsList" class="player-list"></ul>
                </div>
            </div>
            
            <div><strong>Player Up:</strong> <span id="jogadorDaVezAcaoDisplay" style="font-weight:bold; color:blue;"></span></div>
        </div>
      
        <!-- Card Play Section -->
        <div id="cardPlaySection" style="display:none;" class="card-play-section">
            <h4>Play a Card</h4>
            <div id="cardSelectionArea">
                <!-- Card options will be dynamically generated here -->
            </div>
        </div>
      
        <!-- New Card History Section -->
        <div id="cardHistorySection" class="card-history-section" style="display:none;">
            <h4>Cards Played This Round</h4>
            <div id="cardHistoryContainer">
                <table id="cardHistoryTable" class="card-history-table">
                    <thead>
                        <tr>
                            <th>Player</th>
                            <th>Cards Played</th>
                        </tr>
                    </thead>
                    <tbody id="cardHistoryTableBody">
                        <!-- Card history will be dynamically generated here -->
                    </tbody>
                </table>
            </div>
            
            <!-- High cards summary -->
            <div id="highCardsSummary" style="margin-top: 10px;">
                <h5>High Cards Played</h5>
                <div id="highCardsDisplay" class="card-display"></div>
            </div>
        </div>
      </div>
      
      <!-- Right Column -->
      <div class="right-column">
        <!-- New Persistent Palpite Tracker -->
        <div id="palpiteTrackerSection" class="palpite-tracker">
            <h4>Palpites & Progress Tracker</h4>
            <div id="palpiteTrackerList"></div>
            
            <div id="trickProgressSection" class="trick-progress">
                <div class="trick-progress-label">Tricks Played: <span id="tricksPlayedCount">0</span>/<span id="totalTricksCount">0</span></div>
                <div class="trick-progress-bar">
                    <div id="trickProgressFill" class="trick-progress-fill" style="width: 0%"></div>
                </div>
            </div>
        </div>
        
        <div id="palpiteSection" class="palpite-section" style="display:none;">
            <h4>Palpites Feitos:</h4>
            <ul id="palpitesFeitosList"></ul>
            <div id="myPalpiteInputArea" style="display:none;">
                <label>Your Palpite (0-<span id="maxPalpite"></span>): <input type="number" id="palpiteInput" min="0"></label>
                <button id="submitPalpiteBtn">Submit Palpite</button>
                <div id="palpiteError" class="error-msg"></div>
            </div>
        </div>
        
        <div id="currentTrickSection" style="margin-top: 15px; display: none;">
            <h4>Current Trick</h4>
            <div id="cardsInPlayDisplay" class="card-display">
                <!-- Cards in play will be shown here -->
            </div>
            <!-- Trick winner announcement -->
            <div id="trickWinnerAnnounce" class="trick-winner-display" style="display: none;"></div>
        </div>
        
        <div id="roundResultsSection" style="display:none;" class="round-results-section">
            <h4>Round Results</h4>
            <div class="card-display">
                <div><strong>Trick Winners:</strong> <span id="trickWinnersDisplay"></span></div>
                <h5>Lives Lost:</h5>
                <ul id="livesLostList" class="player-list"></ul>
            </div>
        </div>

        <button id="requestNextRoundBtn" style="display:none;">Request Next Round</button>
      </div>
    </div>
    
    <h4>Event Log:</h4>
    <div id="log"></div>
  </div>

<script>
  const logElement = document.getElementById('log');
  const log = (msg, type = 'info') => {
    const prefix = type === 'error' ? '❌ ERROR: ' : (type === 'event' ? '🔹 ' : (type === 'action' ? '➡️ ' : '✔ '));
    logElement.textContent += prefix + msg + '\n';
    logElement.scrollTop = logElement.scrollHeight;
  };

  // Views
  const loginView = document.getElementById('loginView');
  const lobbyView = document.getElementById('lobbyView');
  const gameView = document.getElementById('gameView');
  function showView(viewId) {
    console.log(`[DEBUG] showView attempting to activate: ${viewId}`);
    loginView.classList.remove('active');
    lobbyView.classList.remove('active');
    gameView.classList.remove('active');
    const viewToShow = document.getElementById(viewId);
    if (viewToShow) {
        viewToShow.classList.add('active');
        console.log(`[DEBUG] ${viewId} classList after add:`, viewToShow.classList);
    } else {
        console.error(`[DEBUG] View with ID ${viewId} not found in showView.`);
    }
  }

  // Player Context Display
  const connectionStatus = document.getElementById('connectionStatus');
  const playerContextDiv = document.getElementById('playerContext');
  const myPlayerIdSpan = document.getElementById('myPlayerId');
  const mySidSpan = document.getElementById('mySid');
  const myRoomIdSpan = document.getElementById('myRoomId');

  // Login View Elements
  const playerIdInput = document.getElementById('playerIdInput');
  const lobbyCodeInput = document.getElementById('lobbyCodeInput');
  const hostGameBtn = document.getElementById('hostGameBtn');
  const joinGameBtn = document.getElementById('joinGameBtn');

  // Lobby View Elements
  const lobbyIdDisplay = document.getElementById('lobbyIdDisplay');
  const playerList = document.getElementById('playerList');
  const startGameBtn = document.getElementById('startGameBtn');

  // Game View Elements
  const gameLobbyIdDisplay = document.getElementById('gameLobbyIdDisplay');
  const roundPhaseDisplay = document.getElementById('roundPhaseDisplay');
  const dealerRodadaAtualDisplay = document.getElementById('dealerRodadaAtualDisplay');
  const nCartasRodadaAtualDisplay = document.getElementById('nCartasRodadaAtualDisplay');
  const cartaMeioRodadaAtualDisplay = document.getElementById('cartaMeioRodadaAtualDisplay');
  const manilhaRodadaAtualDisplay = document.getElementById('manilhaRodadaAtualDisplay');
  const myHandDisplay = document.getElementById('myHandDisplay');
  const jogadorDaVezAcaoDisplay = document.getElementById('jogadorDaVezAcaoDisplay');
  const requestNextRoundBtn = document.getElementById('requestNextRoundBtn');
  
  // Palpite Section Elements
  const palpiteSection = document.getElementById('palpiteSection');
  const palpitesFeitosList = document.getElementById('palpitesFeitosList');
  const myPalpiteInputArea = document.getElementById('myPalpiteInputArea');
  const palpiteInput = document.getElementById('palpiteInput');
  const maxPalpiteSpan = document.getElementById('maxPalpite');
  const submitPalpiteBtn = document.getElementById('submitPalpiteBtn');
  const palpiteError = document.getElementById('palpiteError');

  // Card Play Section Elements
  const cardPlaySection = document.getElementById('cardPlaySection');
  const cardSelectionArea = document.getElementById('cardSelectionArea');
  const currentTrickSection = document.getElementById('currentTrickSection');
  const cardsInPlayDisplay = document.getElementById('cardsInPlayDisplay');
  const trickWinnerAnnounce = document.getElementById('trickWinnerAnnounce');
  
  // Round Results Section
  const roundResultsSection = document.getElementById('roundResultsSection');
  const trickWinnersDisplay = document.getElementById('trickWinnersDisplay');
  const livesLostList = document.getElementById('livesLostList');
  
  // Lives Tracker
  const livesTrackerList = document.getElementById('livesTrackerList');
  
  // New Palpite Tracker Elements
  const palpiteTrackerSection = document.getElementById('palpiteTrackerSection');
  const palpiteTrackerList = document.getElementById('palpiteTrackerList');
  const tricksPlayedCount = document.getElementById('tricksPlayedCount');
  const totalTricksCount = document.getElementById('totalTricksCount');
  const trickProgressFill = document.getElementById('trickProgressFill');
  
  // Card History Elements
  const cardHistorySection = document.getElementById('cardHistorySection');
  const cardHistoryTableBody = document.getElementById('cardHistoryTableBody');
  const highCardsDisplay = document.getElementById('highCardsDisplay');

  // Client State
  let G_SID = '';
  let G_PLAYER_ID = '';
  let G_ROOM_ID = '';
  let G_IS_HOST = false;
  let G_CURRENT_GAME_STATE = null;
  let G_CARD_HISTORY = []; // Array to store card history for the current round

  // Socket Initialization
  const socket = io(window.location.origin);

  // --- Helper Functions ---
  function updatePlayerContextUI() {
    if (G_PLAYER_ID) {
        myPlayerIdSpan.textContent = G_PLAYER_ID;
        mySidSpan.textContent = G_SID;
        myRoomIdSpan.textContent = G_ROOM_ID || 'N/A';
        playerContextDiv.style.display = 'block';
    } else {
        playerContextDiv.style.display = 'none';
    }
  }

  function updateLobbyView(data) {
    console.log('[DEBUG] updateLobbyView called. Data:', data, 'G_IS_HOST:', G_IS_HOST, 'G_PLAYER_ID:', G_PLAYER_ID);
    G_ROOM_ID = data.room_id;
    lobbyIdDisplay.textContent = G_ROOM_ID;
    updatePlayerContextUI();
    playerList.innerHTML = '';
    data.players.forEach(pid => {
        const li = document.createElement('li');
        li.textContent = pid + (pid === G_PLAYER_ID ? ' (You)' : '') + (pid === data.players[0] ? ' (Host)' : '');
        playerList.appendChild(li);
    });
    const shouldShowStartButton = G_IS_HOST && data.players.length >= 1;
    console.log('[DEBUG] updateLobbyView - Should show Start Game button?', shouldShowStartButton);
    startGameBtn.style.display = shouldShowStartButton ? 'block' : 'none';
    
    // Don't automatically switch to lobby view when updating - only do this for initial cases
    const currentView = document.querySelector('.view.active').id;
    console.log('[DEBUG] Current view is:', currentView);
    
    // Only switch to lobby view if we're on login view or explicitly told to
    if (currentView === 'loginView' || data.force_lobby_view) {
        showView('lobbyView');
    }
  }

  // Function to update the cards in play display
  function updateCardsInPlayDisplay(cardsInPlay) {
    if (!cardsInPlay || cardsInPlay.length === 0) {
      currentTrickSection.style.display = 'none';
      trickWinnerAnnounce.style.display = 'none';
      return;
    }
    
    currentTrickSection.style.display = 'block';
    cardsInPlayDisplay.innerHTML = '';
    
    // Find the strongest card based on the game logic
    let strongestPlayer = null;
    let strongestCard = null;
    
    // If we have a trick_winner from the game state, use that
    if (G_CURRENT_GAME_STATE && G_CURRENT_GAME_STATE.current_trick_leader) {
      strongestPlayer = G_CURRENT_GAME_STATE.current_trick_leader;
    } else {
      // Simplified logic to determine strongest card
      // Ideally this would match server-side logic, but we'll use a simplified version
      // For a full implementation, we'd need to know the manilha and card ordering
      const manilha = G_CURRENT_GAME_STATE ? G_CURRENT_GAME_STATE.manilha_rodada_atual : null;
      
      // Card values from lowest to highest
      const cardValues = ['4', '5', '6', '7', 'Q', 'J', 'K', 'A', '2', '3'];
      const naipesOrder = {'♦': 0, '♠': 1, '♥': 2, '♣': 3}; // For manilha tiebreaks
      
      let highestScore = -1;
      
      for (const [playerId, card] of cardsInPlay) {
        if (!card) continue;
        
        let cardValue = null;
        let naipe = null;
        
        // Extract value and naipe
        if (typeof card === 'string') {
          // Format might be "A♥" - first char is value, second is naipe
          cardValue = card.substring(0, card.length - 1);
          naipe = card.substring(card.length - 1);
        } else if (card.valor && card.naipe) {
          // Format might be an object with value and naipe properties
          cardValue = card.valor;
          naipe = card.naipe;
        } else {
          console.warn("Unknown card format:", card);
          continue;
        }
        
        // Calculate card strength
        let score = 0;
        
        // If it's a manilha, it's the strongest
        if (manilha && cardValue === manilha) {
          score = 1000 + (naipesOrder[naipe] || 0);
        } else {
          // Otherwise use regular card order
          score = cardValues.indexOf(cardValue);
        }
        
        if (score > highestScore) {
          highestScore = score;
          strongestPlayer = playerId;
          strongestCard = card;
        }
      }
    }
    
    cardsInPlay.forEach(([playerId, card]) => {
      const cardContainer = document.createElement('div');
      cardContainer.className = 'player-card-played';
      if (playerId === G_PLAYER_ID) {
        cardContainer.classList.add('current-player-card');
      }
      
      const playerName = document.createElement('span');
      playerName.className = 'card-player-name';
      playerName.textContent = playerId + (playerId === G_PLAYER_ID ? ' (You)' : '');
      cardContainer.appendChild(playerName);
      
      const cardSpan = document.createElement('span');
      cardSpan.className = 'card-item';
      // Add red color for hearts and diamonds
      if (card && (card.includes('♥') || card.includes('♦'))) {
        cardSpan.classList.add('card-red');
      } else {
        cardSpan.classList.add('card-black');
      }
      
      // Highlight the strongest card
      if (playerId === strongestPlayer) {
        cardSpan.classList.add('strongest-card');
      }
      
      cardSpan.textContent = card;
      cardContainer.appendChild(cardSpan);
      
      cardsInPlayDisplay.appendChild(cardContainer);
    });
    
    // Show trick winner if it was just completed
    if (G_CURRENT_GAME_STATE && G_CURRENT_GAME_STATE.last_trick_winner && 
        G_CURRENT_GAME_STATE.event_type === 'trick_completed') {
      trickWinnerAnnounce.textContent = `${G_CURRENT_GAME_STATE.last_trick_winner} won this trick!`;
      trickWinnerAnnounce.style.display = 'block';
      
      // Update trick progress in the progress tracker
      updateTrickProgress();
    } else {
      trickWinnerAnnounce.style.display = 'none';
    }
  }
  
  function updateGameView(gameState) {
    console.log("[DEBUG] updateGameView called. gameState:", JSON.parse(JSON.stringify(gameState)), "Current G_PLAYER_ID:", G_PLAYER_ID);
    G_CURRENT_GAME_STATE = gameState;
    if (!gameState) {
        log('Received null game state, cannot update game view.', 'error');
        console.error("[DEBUG] updateGameView: gameState is null or undefined.");
        showView('lobbyView');
        return;
    }

    try {
        // Update basic game info
        gameLobbyIdDisplay.textContent = gameState.room_id || G_ROOM_ID;
        roundPhaseDisplay.textContent = gameState.round_phase || 'N/A';
        dealerRodadaAtualDisplay.textContent = gameState.dealer_rodada_atual || 'N/A';
        nCartasRodadaAtualDisplay.textContent = gameState.n_cartas_rodada_atual !== undefined ? gameState.n_cartas_rodada_atual : '0';
        cartaMeioRodadaAtualDisplay.textContent = gameState.carta_meio_rodada_atual || 'N/A';
        manilhaRodadaAtualDisplay.textContent = gameState.manilha_rodada_atual || 'N/A';
        
        // Update lives tracker
        updateLivesTracker(gameState.lives);
        
        // Update palpite tracker and progress
        updatePalpiteTracker();
        updateTrickProgress();
        
        // Update card history
        updateCardHistory();
        
        console.log("[DEBUG] updateGameView: Basic info set. G_PLAYER_ID for hand:", G_PLAYER_ID);
        console.log("[DEBUG] updateGameView: Maos rodada atual:", gameState.maos_rodada_atual);

        // Format player's own hand with card styling
        if (gameState.maos_rodada_atual && gameState.maos_rodada_atual[G_PLAYER_ID]) {
            const myHand = gameState.maos_rodada_atual[G_PLAYER_ID];
            myHandDisplay.innerHTML = '';
            
            if (myHand.length === 1 && myHand[0] === "HIDDEN") {
                const hiddenCard = document.createElement('span');
                hiddenCard.className = 'card-item hidden-card';
                hiddenCard.textContent = 'HIDDEN';
                myHandDisplay.appendChild(hiddenCard);
            } else {
                myHand.forEach(card => {
                    const cardSpan = document.createElement('span');
                    cardSpan.className = 'card-item';
                    // Add red color for hearts and diamonds
                    if (card.includes('♥') || card.includes('♦')) {
                        cardSpan.classList.add('card-red');
                    } else {
                        cardSpan.classList.add('card-black');
                    }
                    cardSpan.textContent = card;
                    myHandDisplay.appendChild(cardSpan);
                });
            }
            
            console.log("[DEBUG] updateGameView: My hand set to styled cards");
        } else {
            myHandDisplay.textContent = 'Waiting for cards...';
            console.log("[DEBUG] updateGameView: Hand for player", G_PLAYER_ID, 
                "not found in maos_rodada_atual. Keys:", 
                gameState.maos_rodada_atual ? Object.keys(gameState.maos_rodada_atual) : "no maos_rodada_atual");
        }

        // Handle displaying other players' cards in 1-card rounds
        const otherPlayersCardsDiv = document.getElementById('otherPlayersCards');
        const otherPlayersCardsList = document.getElementById('otherPlayersCardsList');
        otherPlayersCardsList.innerHTML = '';
        
        console.log("[DEBUG] Card visibility check: n_cartas_rodada_atual =", gameState.n_cartas_rodada_atual, 
                    "can_see_others_cards =", gameState.can_see_others_cards);
        console.log("[DEBUG] All players' cards:", gameState.maos_rodada_atual);
        
        if (gameState.n_cartas_rodada_atual === 1) {
            // In 1-card rounds, we can see others' cards but not our own
            otherPlayersCardsDiv.style.display = 'block';
            let foundVisibleCards = false;
            
            for (const [playerId, hand] of Object.entries(gameState.maos_rodada_atual)) {
                console.log("[DEBUG] Processing player cards:", playerId, hand);
                if (playerId !== G_PLAYER_ID && hand && hand.length > 0) {
                    foundVisibleCards = true;
                    const li = document.createElement('li');
                    
                    // Create player name span
                    const playerSpan = document.createElement('span');
                    playerSpan.textContent = `${playerId}: `;
                    li.appendChild(playerSpan);
                    
                    // Create card display with styling
                    hand.forEach(card => {
                        if (card !== "HIDDEN") {
                            const cardSpan = document.createElement('span');
                            cardSpan.className = 'card-item';
                            // Add red color for hearts and diamonds
                            if (card.includes('♥') || card.includes('♦')) {
                                cardSpan.classList.add('card-red');
                            } else {
                                cardSpan.classList.add('card-black');
                            }
                            cardSpan.textContent = card;
                            li.appendChild(cardSpan);
                        } else {
                            const hiddenSpan = document.createElement('span');
                            hiddenSpan.className = 'card-item hidden-card';
                            hiddenSpan.textContent = 'HIDDEN';
                            li.appendChild(hiddenSpan);
                        }
                    });
                    
                    otherPlayersCardsList.appendChild(li);
                    console.log("[DEBUG] Added styled card for player:", playerId);
                }
            }
            
            // If no visible cards were found
            if (!foundVisibleCards) {
                const li = document.createElement('li');
                li.textContent = 'No other players have visible cards yet.';
                otherPlayersCardsList.appendChild(li);
                console.log("[DEBUG] No other players' cards found to display");
            }
        } else {
            // In other rounds, hide this section
            otherPlayersCardsDiv.style.display = 'none';
            console.log("[DEBUG] Not a 1-card round, hiding other players' cards");
        }

        const playerUp = gameState.jogador_da_vez_acao || 'N/A';
        jogadorDaVezAcaoDisplay.textContent = playerUp + (playerUp === G_PLAYER_ID ? ' (Your Turn!)' : '');
        console.log("[DEBUG] updateGameView: Player up set.");

        // Highlight and activate UI elements based on whose turn it is
        const isMyTurn = (playerUp === G_PLAYER_ID);
        
        // Clear any previous turn highlights
        document.querySelectorAll('.my-turn').forEach(el => el.classList.remove('my-turn'));

        palpiteError.textContent = '';
        if (gameState.round_phase === 'waiting_palpites') {
            // Hide round results section if shown from previous round
            roundResultsSection.style.display = 'none';
            
            palpiteSection.style.display = 'block';
            palpitesFeitosList.innerHTML = '';
            if (gameState.palpites_feitos_rodada_atual) {
                for (const [player, palpite] of Object.entries(gameState.palpites_feitos_rodada_atual)) {
                    const li = document.createElement('li');
                    li.textContent = `${player}: ${palpite}`;
                    if (player === G_PLAYER_ID) {
                        li.style.fontWeight = 'bold';
                    }
                    palpitesFeitosList.appendChild(li);
                }
            }
            if (isMyTurn) {
                myPalpiteInputArea.style.display = 'block';
                myPalpiteInputArea.classList.add('my-turn');
                maxPalpiteSpan.textContent = gameState.n_cartas_rodada_atual;
                palpiteInput.max = gameState.n_cartas_rodada_atual;
                palpiteInput.value = '';
                submitPalpiteBtn.disabled = false;
                
                // Flash effect to draw attention
                setTimeout(() => {
                    myPalpiteInputArea.style.transition = 'background-color 0.5s';
                    myPalpiteInputArea.style.backgroundColor = '#e6ffe6';
                    setTimeout(() => {
                        myPalpiteInputArea.style.backgroundColor = '';
                    }, 1000);
                }, 100);
                
                log(`It's your turn to make a palpite (bet)!`, 'action');
            } else {
                myPalpiteInputArea.style.display = 'none';
                
                if (playerUp) {
                    log(`Waiting for ${playerUp} to make their palpite...`, 'info');
                }
            }
            console.log("[DEBUG] updateGameView: Palpite section updated.");
        } else {
            palpiteSection.style.display = 'none';
        }

        if (gameState.round_phase === 'waiting_card_play') {
            cardPlaySection.style.display = 'block';
            
            // Setup card selection UI
            setupCardSelectionUI(gameState.maos_rodada_atual[G_PLAYER_ID], isMyTurn);
            
            // Update the cards in play display
            if (gameState.cartas_na_mesa_rodada_atual) {
                updateCardsInPlayDisplay(gameState.cartas_na_mesa_rodada_atual);
            }
            
            if (isMyTurn) {
                cardPlaySection.classList.add('my-turn');
                
                // Flash effect to draw attention
                setTimeout(() => {
                    cardPlaySection.style.transition = 'background-color 0.5s';
                    cardPlaySection.style.backgroundColor = '#e6ffe6';
                    setTimeout(() => {
                        cardPlaySection.style.backgroundColor = '';
                    }, 1000);
                }, 100);
                
                log(`It's your turn to play a card!`, 'action');
            } else {
                if (playerUp) {
                    log(`Waiting for ${playerUp} to play a card...`, 'info');
                }
            }
        } else {
            cardPlaySection.style.display = 'none';
            currentTrickSection.style.display = 'none';
        }
        
        // Show round results if round is over
        if (gameState.round_phase === 'round_over' || gameState.event_type === 'round_over') {
            showRoundResults(gameState);
        }
        
        requestNextRoundBtn.style.display = (G_IS_HOST && (gameState.round_phase === 'round_over' || (gameState.game_over_global && !gameState.game_over_global_means_final))) ? 'block' : 'none';
        if (gameState.game_over_global && G_IS_HOST) {
            log("GAME OVER. Host can request a new game (next round).", 'event');
        }
        console.log("[DEBUG] updateGameView: Visibility for sections and next round button set.");

    } catch (error) {
        console.error("[DEBUG] Error during updateGameView DOM manipulation:", error);
        log("Client-side error updating game view. Check console.", 'error');
    }

    showView('gameView');
    updatePlayerContextUI();
    console.log("[DEBUG] updateGameView finished.");
  }
  
  function updateLivesTracker(lives) {
    livesTrackerList.innerHTML = '';
    
    if (!lives) return;
    
    // Sort players by lives (high to low)
    const sortedPlayers = Object.entries(lives)
        .sort((a, b) => b[1] - a[1])
        .map(entry => ({ id: entry[0], lives: entry[1] }));
    
    sortedPlayers.forEach(player => {
        const li = document.createElement('li');
        const playerSpan = document.createElement('span');
        playerSpan.textContent = `${player.id}${player.id === G_PLAYER_ID ? ' (You)' : ''}: `;
        
        const livesSpan = document.createElement('span');
        livesSpan.className = 'lives-count';
        if (player.lives <= 1) {
            livesSpan.classList.add('critical-lives');
        } else if (player.lives <= 2) {
            livesSpan.classList.add('low-lives');
        }
        livesSpan.textContent = player.lives;
        
        li.appendChild(playerSpan);
        li.appendChild(livesSpan);
        livesTrackerList.appendChild(li);
    });
  }
  
  // Function to update the palpite tracker
  function updatePalpiteTracker() {
    if (!G_CURRENT_GAME_STATE) return;
    
    palpiteTrackerList.innerHTML = '';
    
    // Get palpites and victories from game state
    const palpites = G_CURRENT_GAME_STATE.palpites_feitos_rodada_atual || {};
    const vitorias = G_CURRENT_GAME_STATE.vitorias_rodada_atual || {};
    
    // For all players in the game
    for (const playerId of G_CURRENT_GAME_STATE.players || []) {
      const palpite = palpites[playerId] !== undefined ? palpites[playerId] : '?';
      const tricksWon = vitorias[playerId] || 0;
      
      const trackerItem = document.createElement('div');
      trackerItem.className = 'palpite-tracker-item';
      
      // Player name
      const playerName = document.createElement('span');
      playerName.className = 'player-name';
      playerName.textContent = playerId + (playerId === G_PLAYER_ID ? ' (You)' : '');
      trackerItem.appendChild(playerName);
      
      // Palpite value
      const palpiteValue = document.createElement('span');
      palpiteValue.className = 'palpite-value';
      palpiteValue.textContent = `Bet: ${palpite}`;
      trackerItem.appendChild(palpiteValue);
      
      // Tricks won
      const tricksWonSpan = document.createElement('span');
      tricksWonSpan.className = 'tricks-won';
      tricksWonSpan.textContent = `Won: ${tricksWon}`;
      // Highlight if close to their palpite
      if (palpite !== '?' && tricksWon === palpite) {
        tricksWonSpan.style.color = 'green';
        tricksWonSpan.style.fontWeight = 'bold';
      } else if (palpite !== '?' && Math.abs(tricksWon - palpite) === 1) {
        tricksWonSpan.style.color = 'orange';
      }
      trackerItem.appendChild(tricksWonSpan);
      
      palpiteTrackerList.appendChild(trackerItem);
    }
  }
  
  // Function to update the trick progress
  function updateTrickProgress() {
    if (!G_CURRENT_GAME_STATE) return;
    
    const totalTricks = G_CURRENT_GAME_STATE.n_cartas_rodada_atual || 0;
    const tricksPlayed = G_CURRENT_GAME_STATE.rodada_atual_num_tricks || 0;
    
    // Update the counter text
    tricksPlayedCount.textContent = tricksPlayed;
    totalTricksCount.textContent = totalTricks;
    
    // Update the progress bar
    const progressPercent = totalTricks > 0 ? (tricksPlayed / totalTricks) * 100 : 0;
    trickProgressFill.style.width = `${progressPercent}%`;
    
    // Change color based on progress
    if (progressPercent > 75) {
      trickProgressFill.style.backgroundColor = '#4CAF50'; // Green - almost done
    } else if (progressPercent > 40) {
      trickProgressFill.style.backgroundColor = '#2196F3'; // Blue - in progress
    } else {
      trickProgressFill.style.backgroundColor = '#FFC107'; // Yellow - just started
    }
  }
  
  function setupCardSelectionUI(cards, isMyTurn) {
    cardSelectionArea.innerHTML = '';
    
    if (!cards || !cards.length) return;
    
    // Special case for HIDDEN cards - should only happen in 1-card rounds during palpite phase
    // In card play phase, players should see their own card even in 1-card rounds
    if (cards.length === 1 && cards[0] === "HIDDEN") {
        console.log("[DEBUG] Attempted to setup card selection for HIDDEN card");
        // This shouldn't happen in the card_play phase after our fix,
        // but we'll handle it just in case
        const hiddenCardSpan = document.createElement('span');
        hiddenCardSpan.className = 'card-item hidden-card';
        hiddenCardSpan.textContent = 'HIDDEN';
        cardSelectionArea.appendChild(hiddenCardSpan);
        
        // Add waiting message
        const waitingMsg = document.createElement('p');
        waitingMsg.textContent = 'Waiting for your card to be revealed...';
        cardSelectionArea.appendChild(waitingMsg);
        return;
    }
    
    // Normal handling for visible cards
    cards.forEach((card, index) => {
        const cardBtn = document.createElement('button');
        cardBtn.className = 'card-selection-btn';
        if (card.includes('♥') || card.includes('♦')) {
            cardBtn.classList.add('card-red');
        } else {
            cardBtn.classList.add('card-black');
        }
        cardBtn.textContent = card;
        cardBtn.disabled = !isMyTurn;
        
        cardBtn.onclick = () => {
            log(`Playing card: ${card}`, 'action');
            
            // Update our local card history immediately for better UX
            // The server response will eventually update this as well
            if (G_CARD_HISTORY.length > 0) {
                const myHistoryEntry = G_CARD_HISTORY.find(entry => entry.playerId === G_PLAYER_ID);
                if (myHistoryEntry && !myHistoryEntry.cardsPlayed.includes(card)) {
                    myHistoryEntry.cardsPlayed.push(card);
                    // Update the display
                    updateCardHistory();
                }
            }
            
            socket.emit('submit_card_action', { room_id: G_ROOM_ID, card_index: index });
            // Disable all buttons after selection
            document.querySelectorAll('.card-selection-btn').forEach(btn => btn.disabled = true);
        };
        
        cardSelectionArea.appendChild(cardBtn);
    });
  }
  
  function showRoundResults(gameState) {
    roundResultsSection.style.display = 'block';
    
    // Show trick winners
    if (gameState.vitorias_rodada_atual) {
        const winners = Object.entries(gameState.vitorias_rodada_atual)
            .filter(([_, wins]) => wins > 0)
            .map(([player, wins]) => `${player}: ${wins} trick${wins > 1 ? 's' : ''}`);
        
        trickWinnersDisplay.textContent = winners.length > 0 ? winners.join(', ') : 'None';
    }
    
    // Calculate lives lost based on palpites and vitorias
    livesLostList.innerHTML = '';
    
    if (gameState.palpites_feitos_rodada_atual && gameState.vitorias_rodada_atual) {
        const palpites = gameState.palpites_feitos_rodada_atual;
        const vitorias = gameState.vitorias_rodada_atual;
        
        // Show round summary popup
        setTimeout(() => {
            // Create overall round summary message
            let roundSummary = "Round Results:\n\n";
            let anyLifeLoss = false;
            
            for (const player of gameState.players) {
                if (palpites[player] !== undefined && vitorias[player] !== undefined) {
                    const diff = Math.abs(palpites[player] - vitorias[player]);
                    const result = diff === 0 ? "Perfect bet!" : `-${diff} lives`;
                    if (diff > 0) anyLifeLoss = true;
                    
                    roundSummary += `${player}: Bet ${palpites[player]}, Won ${vitorias[player]} → ${result}\n`;
                    
                    // Also update the results display in the UI
                    const li = document.createElement('li');
                    li.className = 'lives-lost-item';
                    li.classList.add(diff === 0 ? 'lives-lost-zero' : 'lives-lost-nonzero');
                    li.textContent = `${player}: ${diff > 0 ? `-${diff}` : '0'} (Bet: ${palpites[player]}, Won: ${vitorias[player]})`;
                    livesLostList.appendChild(li);
                }
            }
            
            // Show the alert with round results
            alert(roundSummary);
            
            // Show a notification to host if they should start next round
            if (G_IS_HOST && anyLifeLoss && !gameState.game_over_global) {
                // Auto-show the "Request Next Round" button with highlight
                requestNextRoundBtn.style.display = 'block';
                requestNextRoundBtn.style.backgroundColor = '#4CAF50';
                requestNextRoundBtn.style.color = 'white';
                requestNextRoundBtn.style.fontWeight = 'bold';
                
                log("You are the host. Click 'Request Next Round' when ready.", 'action');
            } else if (gameState.game_over_global) {
                log("Game over! Check the lives tracker to see final results.", 'event');
            }
        }, 500);
    }
  }

  // --- Socket Event Handlers ---
  socket.on('connect', () => {
    G_SID = socket.id;
    connectionStatus.textContent = 'Status: Connected!';
    log('Connected to server successfully! Your SID: ' + G_SID, 'event');
    updatePlayerContextUI();
  });

  socket.on('disconnect', () => {
    connectionStatus.textContent = 'Status: Disconnected';
    log('Disconnected from server', 'error');
    // Optionally reset state or disable UI elements
    G_SID = ''; G_PLAYER_ID = ''; G_ROOM_ID = ''; G_IS_HOST = false; G_CURRENT_GAME_STATE = null;
    showView('loginView');
    updatePlayerContextUI();
  });

  socket.on('connected', (data) => { // Server confirms connection and might send SID
    if (data.sid && G_SID !== data.sid) { // G_SID might already be set by socket.id
        G_SID = data.sid;
        log(`SID confirmed by server: ${G_SID}`, 'event');
    }
    updatePlayerContextUI();
  });

  socket.on('error', (data) => log(data.msg, 'error'));
  socket.on('action_error', (data) => {
    log(`Action Error: ${data.msg} (Room: ${data.room_id})`, 'error');
    if (data.room_id === G_ROOM_ID && G_CURRENT_GAME_STATE && G_CURRENT_GAME_STATE.round_phase === 'waiting_palpites') {
        palpiteError.textContent = data.msg;
        submitPalpiteBtn.disabled = false; // Re-enable if error was palpite related
    }
  });

  socket.on('lobby_created', (data) => {
    log(`Lobby created! Code: ${data.room_id}. You are: ${data.your_player_id}`, 'event');
    G_PLAYER_ID = data.your_player_id;
    G_IS_HOST = true;
    console.log('[DEBUG] lobby_created - G_IS_HOST set to true, G_PLAYER_ID:', G_PLAYER_ID);
    updateLobbyView(data);
  });

  socket.on('lobby_joined', (data) => {
    log(`Joined lobby ${data.room_id}. You are: ${data.your_player_id}. Players: ${data.players.join(', ')}`, 'event');
    G_PLAYER_ID = data.your_player_id;
    // Correctly set G_IS_HOST only if this player is the first player (original host)
    G_IS_HOST = (data.players && data.players.length > 0 && data.players[0] === G_PLAYER_ID);
    console.log('[DEBUG] lobby_joined - G_IS_HOST set to:', G_IS_HOST, 'G_PLAYER_ID:', G_PLAYER_ID, 'data.players[0]:', data.players ? data.players[0] : 'N/A');
    
    // Set force_lobby_view to true to ensure view switch
    data.force_lobby_view = true;
    updateLobbyView(data);
    
    if (data.game_state) {
        log('Rejoined active game. Updating view.', 'event');
        updateGameView(data.game_state);
    }
  });

  socket.on('lobby_state', (data) => {
    log(`Lobby update for ${data.room_id}. Players: ${data.players.join(', ')}. Disconnected: ${data.disconnected_player || 'N/A'}`, 'event');
    if (data.room_id === G_ROOM_ID) {
        // Always update the lobby view with latest players
        updateLobbyView(data);
        
        if(G_CURRENT_GAME_STATE && data.game_state) { // If game is active and we get new state
            updateGameView(data.game_state);
        } else if (G_CURRENT_GAME_STATE && !data.game_state && G_CURRENT_GAME_STATE.round_phase !== 'game_over') {
            // Game might have ended or reset, and we were in game view
            log('Game seems to have ended or reset. Returning to lobby view.','event');
            showView('lobbyView');
        }
    }
  });
  
  socket.on('lobby_message', (data) => log(`Lobby Msg (${data.room_id}): ${data.msg}`, 'event'));

  // --- Game Event Handlers (New Structure) ---
  socket.on('game_update', (data) => {
    log(`Game Update (Room: ${data.room_id}, Event: ${data.event_type})`, 'event');
    if (data.room_id !== G_ROOM_ID) return;
    
    // For card_played events, extract the played card before updating game state
    if (data.event_type === "card_played") {
        // Find the card that was played
        const playerId = data.player_who_played;
        
        // If cartas_na_mesa_rodada_atual is available, find the card by player
        if (data.cartas_na_mesa_rodada_atual && Array.isArray(data.cartas_na_mesa_rodada_atual)) {
            const playedCardEntry = data.cartas_na_mesa_rodada_atual.find(entry => 
                entry && entry[0] === playerId);
            
            if (playedCardEntry && playedCardEntry[1]) {
                // Store the played card in the game state for our history tracking
                data.card_played = playedCardEntry[1];
                log(`Card played by ${playerId}: ${data.card_played}`, 'action');
                
                // Update our card history immediately
                if (!G_CARD_HISTORY.length && data.players) {
                    G_CARD_HISTORY = data.players.map(pid => ({ playerId: pid, cardsPlayed: [] }));
                }
                
                if (G_CARD_HISTORY.length > 0) {
                    const playerHistoryEntry = G_CARD_HISTORY.find(entry => entry.playerId === playerId);
                    if (playerHistoryEntry && !playerHistoryEntry.cardsPlayed.includes(data.card_played)) {
                        playerHistoryEntry.cardsPlayed.push(data.card_played);
                    }
                }
            }
        }
    }
    
    // If starting a new round, reset card history
    if (data.event_type === "next_round_started" || data.event_type === "game_started") {
        G_CARD_HISTORY = [];
    }
    
    // Extract all cards in play for card history
    if (data.cartas_na_mesa_rodada_atual && Array.isArray(data.cartas_na_mesa_rodada_atual)) {
        // Make sure card history is initialized
        if (!G_CARD_HISTORY.length && data.players) {
            G_CARD_HISTORY = data.players.map(pid => ({ playerId: pid, cardsPlayed: [] }));
        }
        
        // Add all visible cards to history
        data.cartas_na_mesa_rodada_atual.forEach(([playerId, card]) => {
            if (playerId && card) {
                const playerHistoryEntry = G_CARD_HISTORY.find(entry => entry.playerId === playerId);
                if (playerHistoryEntry && !playerHistoryEntry.cardsPlayed.includes(card)) {
                    playerHistoryEntry.cardsPlayed.push(card);
                }
            }
        });
    }
    
    G_CURRENT_GAME_STATE = data; // The data IS the new game state
    
    // Make sure we're in the game view regardless of the event
    showView('gameView');
    updateGameView(data);
    
    // Specific log messages based on event_type if needed
    if (data.event_type === "game_started") {
        log("Game has officially started! Waiting for first palpite.",'action');
    } else if (data.event_type === "next_round_started") {
        log("Next round set up. Waiting for first palpite.",'action');
    } else if (data.event_type === "palpite_submitted") {
        log(`Palpite by ${data.player_who_bade}: ${data.palpite_value}.`,'action');
    } else if (data.event_type === "card_played") {
        // Log message is handled above where we extract the card
    } else if (data.event_type === "trick_completed") {
        const winner = data.trick_winner || 'Unknown player';
        log(`Trick completed! ${winner} won this trick.`,'event');
        
        // Store the last trick winner for UI display
        data.last_trick_winner = winner;
        
        // Update the cards in play display to highlight the winner
        if (data.cartas_na_mesa_rodada_atual) {
            updateCardsInPlayDisplay(data.cartas_na_mesa_rodada_atual);
        }
        
        // Update palpite tracker and progress after trick completion
        updatePalpiteTracker();
        updateTrickProgress();
        
        // Show who's winning the round so far as a popup notification
        if (data.vitorias_rodada_atual) {
            const leaders = Object.entries(data.vitorias_rodada_atual)
                .filter(([_, wins]) => wins > 0)
                .sort((a, b) => b[1] - a[1])
                .map(([player, wins]) => `${player}: ${wins}`);
                
            if (leaders.length > 0) {
                const leaderBoard = `Current leaders: ${leaders.join(', ')}`;
                log(leaderBoard, 'info');
            }
        }
    } else if (data.event_type === "game_is_over_final") {
        log("GAME IS PERMANENTLY OVER. No more rounds.", 'error');
        alert("The entire game has finished! Check logs for final details.");
        requestNextRoundBtn.style.display = 'none'; // No more rounds
    }
  });

  socket.on('game_started', (data) => {
    log(`Game Started (Room: ${data.room_id}, Players: ${data.players ? data.players.join(', ') : 'unknown'})`, 'event');
    
    // Always update to game view when game_started is received
    // Don't check if the player is in data.players, as that can cause issues
    G_CURRENT_GAME_STATE = data;
    updateGameView(data);
    log("Game has officially started! Waiting for first palpite.", 'action');
  });

  socket.on('prompt_palpite', (data) => {
    log(`Prompt Palpite (Room: ${data.room_id}): Player ${data.jogador_da_vez_acao}'s turn.`, 'event');
    if (data.room_id !== G_ROOM_ID) return;
    G_CURRENT_GAME_STATE = data;
    updateGameView(data); 
  });

  socket.on('prompt_card_play', (data) => {
    log(`Prompt Card Play (Room: ${data.room_id}): Player ${data.jogador_da_vez_acao}'s turn. (UI TBD)`, 'event');
    if (data.room_id !== G_ROOM_ID) return;
    G_CURRENT_GAME_STATE = data;
    updateGameView(data); 
     // Add UI logic here to enable card selection for the current player
  });
  
  socket.on('round_results', (data) => { // Expecting this after card play is done
      log(`Round Results (Room: ${data.room_id}): ${JSON.stringify(data)}`, 'event');
      if (data.room_id !== G_ROOM_ID) return;
      G_CURRENT_GAME_STATE = data;
      
      // Reset card history for new round
      G_CARD_HISTORY = [];
      
      updateGameView(data);
      // Host can now enable next round button if game not over
  });


  // --- Button Click Handlers ---
  hostGameBtn.onclick = () => {
    G_PLAYER_ID = playerIdInput.value.trim();
    if (!G_PLAYER_ID) { alert('Please enter a Player ID.'); return; }
    log(`Attempting to host game as ${G_PLAYER_ID}...`, 'action');
    socket.emit('create_lobby', { player_id: G_PLAYER_ID });
  };

  joinGameBtn.onclick = () => {
    G_PLAYER_ID = playerIdInput.value.trim();
    const roomIdToJoin = lobbyCodeInput.value.trim().toUpperCase();
    if (!G_PLAYER_ID) { alert('Please enter a Player ID.'); return; }
    if (!roomIdToJoin) { alert('Please enter a Lobby Code.'); return; }
    log(`Attempting to join lobby ${roomIdToJoin} as ${G_PLAYER_ID}...`, 'action');
    socket.emit('join_lobby', { room_id: roomIdToJoin, player_id: G_PLAYER_ID });
  };

  startGameBtn.onclick = () => {
    console.log('[DEBUG] Start Game button clicked. G_ROOM_ID:', G_ROOM_ID, 'G_PLAYER_ID:', G_PLAYER_ID, 'G_IS_HOST:', G_IS_HOST);
    if (!G_ROOM_ID) { 
        log('No current room to start game in.', 'error'); 
        console.error('[DEBUG] Start Game click failed: G_ROOM_ID is not set.');
        return; 
    }
    log(`(Host ${G_PLAYER_ID}) is starting game in lobby ${G_ROOM_ID}...`, 'action');
    socket.emit('start_game', { room_id: G_ROOM_ID });
  };

  requestNextRoundBtn.onclick = () => {
    if (!G_ROOM_ID) { log('No current room for next round.', 'error'); return; }
    log(`(Host ${G_PLAYER_ID}) requesting next round for lobby ${G_ROOM_ID}...`, 'action');
    socket.emit('request_next_round_action', { room_id: G_ROOM_ID });
  };

  submitPalpiteBtn.onclick = () => {
    const palpiteNum = parseInt(palpiteInput.value, 10);
    // Basic validation on client side as well
    if (isNaN(palpiteNum) || palpiteNum < 0 || palpiteNum > G_CURRENT_GAME_STATE.n_cartas_rodada_atual) {
        palpiteError.textContent = `Invalid palpite. Must be 0-${G_CURRENT_GAME_STATE.n_cartas_rodada_atual}.`;
        return;
    }
    palpiteError.textContent = '';
    submitPalpiteBtn.disabled = true; // Prevent double submission
    log(`Submitting palpite: ${palpiteNum}`, 'action');
    socket.emit('submit_palpite_action', { room_id: G_ROOM_ID, palpite: palpiteNum });
  };
  
  // Initial setup
  showView('loginView');
  playerIdInput.value = 'P' + Math.floor(Math.random() * 100 + 1); // Random default player ID
  updatePlayerContextUI();

  // Function to update the card history display
  function updateCardHistory() {
    if (!G_CURRENT_GAME_STATE) return;
    
    // Show/hide card history section based on game phase
    if (G_CURRENT_GAME_STATE.round_phase === "waiting_palpites") {
      // Don't show history when we're still making bets
      cardHistorySection.style.display = 'none';
      return;
    } else {
      cardHistorySection.style.display = 'block';
    }
    
    // Get all cards played from the server data
    if (G_CURRENT_GAME_STATE.all_cards_played) {
      // If the server directly provides all_cards_played, use that data
      G_CARD_HISTORY = G_CURRENT_GAME_STATE.all_cards_played;
    } else {
      // Otherwise, try to extract from the current state and trick history
      
      // Initialize player card history if it doesn't exist yet
      if (!G_CARD_HISTORY.length && G_CURRENT_GAME_STATE.players) {
        G_CARD_HISTORY = G_CURRENT_GAME_STATE.players.map(playerId => ({
          playerId,
          cardsPlayed: []
        }));
      }
      
      // Check if we have a new card played to add to history
      if (G_CURRENT_GAME_STATE.event_type === "card_played" && G_CURRENT_GAME_STATE.player_who_played) {
        const playerWhoPlayed = G_CURRENT_GAME_STATE.player_who_played;
        let cardPlayed = G_CURRENT_GAME_STATE.card_played;
        
        // Try to find the card in cartas_na_mesa_rodada_atual if not directly provided
        if (!cardPlayed && G_CURRENT_GAME_STATE.cartas_na_mesa_rodada_atual) {
          const cardEntry = G_CURRENT_GAME_STATE.cartas_na_mesa_rodada_atual.find(entry => 
            entry && entry[0] === playerWhoPlayed);
          
          if (cardEntry && cardEntry[1]) {
            cardPlayed = cardEntry[1];
          }
        }
        
        // Add the card to history if we found it
        if (cardPlayed) {
          const playerHistoryEntry = G_CARD_HISTORY.find(entry => entry.playerId === playerWhoPlayed);
          
          if (playerHistoryEntry && !playerHistoryEntry.cardsPlayed.includes(cardPlayed)) {
            playerHistoryEntry.cardsPlayed.push(cardPlayed);
          }
        }
      }
      
      // Check for cards in play to add any missing cards
      if (G_CURRENT_GAME_STATE.cartas_na_mesa_rodada_atual) {
        G_CURRENT_GAME_STATE.cartas_na_mesa_rodada_atual.forEach(([playerId, card]) => {
          if (playerId && card) {
            const playerHistoryEntry = G_CARD_HISTORY.find(entry => entry.playerId === playerId);
            
            if (playerHistoryEntry && !playerHistoryEntry.cardsPlayed.includes(card)) {
              playerHistoryEntry.cardsPlayed.push(card);
            }
          }
        });
      }
    }
    
    // Update the table with current card history
    cardHistoryTableBody.innerHTML = '';
    
    // Sort players to match player order in the game
    const sortedHistory = [...G_CARD_HISTORY].sort((a, b) => {
      const indexA = G_CURRENT_GAME_STATE.players.indexOf(a.playerId);
      const indexB = G_CURRENT_GAME_STATE.players.indexOf(b.playerId);
      return indexA - indexB;
    });
    
    // Add rows for each player
    sortedHistory.forEach(entry => {
      const row = document.createElement('tr');
      
      // Add player name cell
      const playerCell = document.createElement('td');
      playerCell.textContent = entry.playerId + (entry.playerId === G_PLAYER_ID ? ' (You)' : '');
      if (entry.playerId === G_PLAYER_ID) {
        playerCell.style.fontWeight = 'bold';
      }
      row.appendChild(playerCell);
      
      // Add cards played cell
      const cardsCell = document.createElement('td');
      
      if (!entry.cardsPlayed || entry.cardsPlayed.length === 0) {
        cardsCell.textContent = 'No cards played yet';
        cardsCell.style.fontStyle = 'italic';
        cardsCell.style.color = '#777';
      } else {
        // For each card, create a styled card span
        entry.cardsPlayed.forEach(card => {
          const cardSpan = document.createElement('span');
          cardSpan.className = 'card-history-mini-card';
          
          // Add red color for hearts and diamonds
          if (card && (card.includes('♥') || card.includes('♦'))) {
            cardSpan.style.color = 'red';
          }
          
          // Highlight high-value cards (A, 2, 3 and manilha)
          const manilha = G_CURRENT_GAME_STATE.manilha_rodada_atual;
          const isManilha = manilha && card.includes(manilha);
          const isHighCard = card.includes('A') || card.includes('2') || card.includes('3');
          
          if (isManilha) {
            cardSpan.classList.add('manilha-card');
          } else if (isHighCard) {
            cardSpan.classList.add('high-value-card');
          }
          
          cardSpan.textContent = card;
          cardsCell.appendChild(cardSpan);
        });
      }
      
      row.appendChild(cardsCell);
      cardHistoryTableBody.appendChild(row);
    });
    
    // Update high cards summary
    updateHighCardsSummary();
  }
  
  // Function to update the high cards summary section
  function updateHighCardsSummary() {
    if (!G_CURRENT_GAME_STATE) return;
    
    highCardsDisplay.innerHTML = '';
    
    // Group all cards played from the card history
    const allCardsPlayed = [];
    G_CARD_HISTORY.forEach(player => {
      if (player.cardsPlayed && player.cardsPlayed.length > 0) {
        allCardsPlayed.push(...player.cardsPlayed);
      }
    });
    
    if (allCardsPlayed.length === 0) {
      const noCardsMsg = document.createElement('p');
      noCardsMsg.textContent = 'No cards played yet in this round';
      noCardsMsg.style.fontStyle = 'italic';
      noCardsMsg.style.color = '#777';
      highCardsDisplay.appendChild(noCardsMsg);
      return;
    }
    
    // Define high cards (manilha, A, 2, 3)
    const manilha = G_CURRENT_GAME_STATE.manilha_rodada_atual;
    const highCardValues = ['A', '2', '3', manilha].filter(v => v); // Filter out undefined values
    
    // Display high cards played
    const highCardsTitle = document.createElement('p');
    highCardsTitle.textContent = 'High cards played this round:';
    highCardsTitle.style.marginBottom = '5px';
    highCardsDisplay.appendChild(highCardsTitle);
    
    // For each high card value
    ['A', '2', '3'].forEach(value => {
      // Find cards with this value
      const cardsOfThisValue = allCardsPlayed.filter(card => card && card.includes(value));
      
      if (cardsOfThisValue.length > 0) {
        const valueRow = document.createElement('div');
        valueRow.style.margin = '5px 0';
        
        const valueLabel = document.createElement('span');
        valueLabel.textContent = `${value}: `;
        valueLabel.style.fontWeight = 'bold';
        valueRow.appendChild(valueLabel);
        
        cardsOfThisValue.forEach(card => {
          const cardSpan = document.createElement('span');
          cardSpan.className = 'card-history-mini-card high-value-card';
          
          if (card && (card.includes('♥') || card.includes('♦'))) {
            cardSpan.style.color = 'red';
          }
          
          cardSpan.textContent = card;
          valueRow.appendChild(cardSpan);
        });
        
        highCardsDisplay.appendChild(valueRow);
      }
    });
    
    // Display manilhas played
    if (manilha) {
      const manilhaCards = allCardsPlayed.filter(card => card && card.includes(manilha));
      
      if (manilhaCards.length > 0) {
        const manilhaRow = document.createElement('div');
        manilhaRow.style.margin = '5px 0';
        
        const manilhaLabel = document.createElement('span');
        manilhaLabel.textContent = `Manilha (${manilha}): `;
        manilhaLabel.style.fontWeight = 'bold';
        manilhaRow.appendChild(manilhaLabel);
        
        manilhaCards.forEach(card => {
          const cardSpan = document.createElement('span');
          cardSpan.className = 'card-history-mini-card manilha-card';
          
          if (card && (card.includes('♥') || card.includes('♦'))) {
            cardSpan.style.color = 'red';
          }
          
          cardSpan.textContent = card;
          manilhaRow.appendChild(cardSpan);
        });
        
        highCardsDisplay.appendChild(manilhaRow);
      }
    }
  }

</script>
</body>
</html>
